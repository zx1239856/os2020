# Lab 7实验报告

计76 张翔 2017011568

## 练习0
需要将`kern/trap/trap.c`时钟中断处理部分`sched_class_proc_tick`改为`run_timer_list`.

## 练习1
#### `ucore`内核级信号量的设计实现
`ucore`的信号量定义在`kern/sync/sem.h`中
```C
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```

在`kern/sync/sem.c`中有其相应实现，其中有初始化`sem_init`，V操作`up`以及P操作`down`。
+ `sem_init`: 初始化信号量的值以及等待队列
+ `up`: 
    + 对应信号量的V操作，与课件不同，`ucore`的信号量的value恒为非负，当前等待中的进程被放入了`wait_queue`中，因此代码中当`wait_queue`为空时相当于`value >= 0`，直接加1，否则等效于课件中的`value < 0`，从队列中取出一个进程并唤醒。
    + 操作时需要关闭中断，以保证对`wait_queue`以及`value`互斥访问。
+ `down`:
    + 对应信号量的P操作，如果`value > 0`，表示有可用资源，将其减1并立即返回，表示信号量被消耗。
    + 如果`value = 0`，对应课件中`value <= 0`的情况，此时无可用资源，将当前进程放入等待队列，状态置为`SLEEPING`，使用`schedule`切换到其他进程；当进程被重新唤醒后，将其从等待队列中删除。
    + 操作时同样需要关中断。
    + 此操作会阻塞进程
+ `try_down`: 与`down`操作语义一致，但不会阻塞当前进程
+ `wait_queue`: 使用链表实现的队列，用以存放等待信号量的进程

#### 用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同
在用户态实现信号量机制的代码逻辑是相同的，但实现的麻烦在于不能像`ucore`内核信号量一样直接关中断以保证操作的原子性。这需要内核为用户态程序提供一种加锁的机制，可以参考Linux `Futex`的设计，提供一个system call来帮助用户态程序对变量进行加锁即可。这里的mutex可以使用内核对某个地址处变量的一个0-1信号量来实现，加锁时`value = 0`，否则为1。

内核与用户态信号量异同： 二者实现逻辑是完全相同的，但实现信号量时能够使用的互斥访问的机制不同，内核态可以直接关中断/调用原子操作指令Test and Set，而用户态程序需要依赖内核提供相应的原子操作机制如mutex等来实现互斥。


## 练习2
#### `ucore`内核级条件变量的设计实现
条件变量定义在`kern/sync/monitor.h`中
```C
typedef struct condvar{
    semaphore_t sem;
    int count;
    monitor_t * owner;
} condvar_t;
```
它被管程持有，一个管程可以有多个条件变量，而底层均通过信号量来实现。管程定义如下
```C
typedef struct monitor{
    semaphore_t mutex;
    semaphore_t next;
    int next_count;
    condvar_t *cv;
} monitor_t;
```

管程中的`next`实际上是所有因为调用管程内条件变量的`cond_signal`而进入睡眠的进程，它们都储存在信号量内部的`wait_queue`中，`next_count`记录了这种进程的个数。而条件变量的`sem`内部是所有因为调用`cond_wait`而进入睡眠的进程，即等待当前条件变量的进程，`count`记录了它们的数量。

**操作流程**：
+ 初始化`monitor_init`: 管程初始化时，`mutex`被初始化为0-1信号量（值为1），用于保持管程的互斥访问；而创建的条件变量内部的`sem`以及管程的`next`均被初始化为值为0的0-1信号量。
+ `cond_signal`:
    + 它用于激活某一个在等待条件变量的进程
    + 首先检查条件变量的`count`，它表示当前等待该条件变量的进程数量；如果大于0，表示有某个进程B因为执行了`cond_signal`而睡眠，将对应的`sem`进行up操作以唤醒B，而当前进程A需要睡眠，它将管程的`next`信号量进行down操作，并将`next_count`加1。
    + 当前进程被唤醒后，`down(&(cvp->owner->next))`操作返回，可以将`next_count`减1。
+ `cond_wait`:
    + 用于等待某个条件变量
    + 调用时，将等待该条件变量的进程数量加1
    + 对于`owner->next_count`有两种情况，若它大于0，说明至少有1个进程因为`cond_signal`而睡眠，此时唤醒其中一个进程，而当前进程使用`down(&(cvp->sem))`进入睡眠；若它小于等于0，说明没有进程因为`cond_signal`而睡眠，则需要唤醒因为互斥而无法访问管程的进程，并将当前进程睡眠
    + 等待该条件变量的进程被唤醒后，`down(&(cvp->sem))`返回，将等待数量减1即可

#### 给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同
+ `ucore`对条件变量和管程的实现是基于信号量的，如果按照上面实现了用户态的信号量，相应的代码也应该能直接迁移到用户态运行

+ 也可以将条件变量封装成系统调用

  

  **异同**

+ 相同：实现逻辑相同

+ 不同：用户态实现条件变量必须依靠内核提供的支持(semaphore, mutex, etc.)，而内核态实现则不需要



#### 能否不用基于信号量机制来完成条件变量

可以，直接维护一个等待队列和一个互斥锁即可，具体实现为
+ 初始化等待队列
+ `signal`: 加锁（关中断），若队列非空，选择等待队列中的第一个进程，移出队列，唤醒它，释放锁（开中断），切换进程
+ `wait`：加锁，将当前进程加入等待队列，置为`SLEEPING`状态，释放锁，若管程内`next_count`为0，则释放管程的互斥锁，最后切换进程



## 总结

#### 实验中涉及的知识点
+ 互斥访问机制
+ 信号量
+ 条件变量、管程

#### 未涉及的知识点
+ 读者-写着问题
+ IPC
+ 纯软件实现同步