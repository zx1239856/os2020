# Lab 8实验报告

计76 张翔 2017011568

## 练习1
#### 设计实现

`sfs_io_nolock`是SFS文件系统的基本IO函数，它被`sfs_io`调用，而后者又被`sys_read/write`。根据读取的起始位置和长度，总共有3个操作阶段：

1. 如果读取的起始位置不对齐，若终止位置在同一块内，从`start`开始读取`end-start`并结束，否则读取`BLOCK_SIZE-start`
2. 读取中间块（若存在）
3. 如果读取的终止位置不对其，读取最后一块从头开始的`end % BLOCK_SIZE`大小

对于对齐块，使用`sfs_block_op`，否则为`sfs_buf_op`。

#### UNIX的PIPE机制

PIPE可以使用circular buffer实现，大致结构如下

```C
struct pipe_inode_info {
    size_t head, tail;
    wait_queue_t rd_wait, wr_wait;
    char *bufs;
    size_t size;
    ...
}
```

**PIPE操作**

需要在`inode`结构体中增加`pipe_inode_info`（放在`device_info`所在的union内）

+ 创建
  + 增加一个`sys_pipe`系统调用，用以创建管道
  + 创建并初始化一个`inode`，并初始化其中的`pipe_t`，缓冲区`buffer`可以动态分配；分配两个`file`以及两个`fd`，一个`O_RDONLY`，一个`O_WRONLY`，`file`的`inode`为之前创建的
  + 将两个`fd`返回给进程
+ 关闭
  + 如果引用数为0，释放`buffer`，销毁pipe
+ 读取
  + 如果缓冲区非空，连续取出字符直到缓冲区为空（可以减少进程切换次数）
  + 如果缓冲区为空，将当前进程加入读取等待队列，置为`SLEEPING`状态，唤醒写入队列中的进程
  + 如果读取到了指定长度的数据，返回读取到的字节数
+ 写入
  + 如果缓冲区未满，连续写入直到缓冲区满
  + 如果缓冲区满，将当前进程加入写入等待队列，置为`SLEEPING`状态，唤醒读取队列中的进程
  + 如果已经写入了全部要求的数据，返回写入的字节数



## 练习2

#### 设计实现

`load_icode`可以在lab 7的代码上加以修改，其中有两处需要修改的地方

+ 原先的实现是从`binary`中读取ELF，改为从`fd`对应的文件中读取，使用`load_icode_read`，读取完成后需要关闭`fd`
+ 增加了`argc, argv`传参的支持，其中`argv`中每个参数的长度不同，需要逐个求得，逐个压入用户栈（从右向左），最后压入`argc`即可

#### UNIX 的硬链接和软链接机制

+ 软链接
  + 创建：如果要创建A的软链接B，只需要将B当作普通文件，创建相应的`inode`，类型设置为`TYPE_LINK`，文件内容为A的路径字符串
  + 删除：直接删除B即可
  + 访问：如果`inode`类型为软链接，读取文件中存储的路径，然后查找该路径对应的`inode`并访问
+ 硬链接
  + 创建：如果要创建A的硬链接B，可以将B所在目录的索引值数组中创建一个`entry`，文件名是B的名字，对应索引节点是A的`inode`所在的块号，同时需要将A对应的`inode`中的`nlinks+1`
  + 访问：无需特殊操作，当作普通文件访问即可
  + 删除：删除时，如果`nlinks > 0`，将其减1，只释放文件所在目录下的索引；如果`nlinks == 0`，释放索引的同时还需要删除对应的`inode`以及数据块。

## 总结

#### 实验中涉及的知识点

+ VFS
+ 文件系统的结构

+ 管道

#### 未涉及的知识点

+ 磁盘调度算法
+ RAID
+ 其他IPC机制，如信号、消息队列、共享内存

